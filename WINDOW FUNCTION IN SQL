https://techtfq.com/video/sql-window-function-sql-queries-tutorial-part-2

#SHOW THE DATABASE 

mysql> SHOW DATABASES;
+--------------------+
| Database           |
+--------------------+
| classicmodels      |
| demos              |
| education          |
| escape             |
| information_schema |
| myflixdb           |
| mysql              |
| performance_schema |
| sys                |
| testdb             |
+--------------------+
10 rows in set (0.03 sec)

#USING THE DATABASES

mysql> USE TESTDB;
Database changed
mysql> SELECT  * FROM employee;
+-------------+------------+-----------+--------+---------------------+------------+------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID |
+-------------+------------+-----------+--------+---------------------+------------+------------+
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |
+-------------+------------+-----------+--------+---------------------+------------+------------+
8 rows in set (0.00 sec)


####FIND THE MAX SALARY FROM OF EMPLOYEE  IN THE TABLE 

mysql> SELECT E.*, MAX(SALARY) AS MAX_SALARY
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | MAX_SALARY |
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |     500000 |
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
1 row in set (0.00 sec)

#HIGHEST SALARY IN WHOLE DEPARTMENT 

mysql> SELECT E.*,
    -> MAX(SALARY) OVER() AS MAX_SALARY
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | MAX_SALARY |
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |     500000 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |     500000 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |     500000 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |     500000 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |     500000 |
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |     500000 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |     500000 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |     500000 |
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
8 rows in set (0.00 sec)

###FIND THE HIGHEST SALARY FROM EACH DEPARTMENT 

mysql> SELECT E.*,
    -> MAX(SALARY) OVER(PARTITION BY DEPARTMENT) AS MAX_SALARY
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | MAX_SALARY |
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |     200000 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |     200000 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |     500000 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |     500000 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |     500000 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |     500000 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |     300000 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |     300000 |
+-------------+------------+-----------+--------+---------------------+------------+------------+------------+
8 rows in set (0.00 sec)

--*BENIFIT OF THE ROW NUMBER IN THE  GIVEN VALUE IS WE GET EACH AND EVERY ROW NUMBER
---BUT WE CAN SEE THIS THERE EMPLOYEE ID IS NOT SHORTED

mysql> SELECT E.*,
    -> ROW_NUMBER() OVER(PARTITION BY DEPARTMENT) AS ROW_NUMBERS
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | ROW_NUMBERS |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |           1 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |           2 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |           1 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |           2 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |           3 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |           4 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |           1 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |           2 |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
8 rows in set (0.00 sec)

#NEED TO ORDERR THE VALUE 

mysql> SELECT E.*,
    -> ROW_NUMBER() OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) AS ROW_NUMBERS
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | ROW_NUMBERS |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |           1 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |           2 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |           1 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |           2 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |           3 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |           4 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |           1 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |           2 |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
8 rows in set (0.00 sec)

#FETCH THE TOP THREE EMPLOYEE SALARY IN EACH DEPARTMENT ORDER BY EMPLOYEE ID 

mysql> SELECT * FROM (SELECT E.*,
    -> ROW_NUMBER() OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) AS ROW_NUMBERS
    -> FROM EMPLOYEE AS E) AS X
    -> WHERE ROW_NUMBERS <= 3;
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | ROW_NUMBERS |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |           1 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |           2 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |           1 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |           2 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |           3 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |           1 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |           2 |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+
7 rows in set (0.00 sec)

#RANK THE OF THE TOP THREE SALARY IN THE EMPLOYEE TABLE 

mysql> SELECT E.*,
    -> RANK() OVER(PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS RANK_NUMBERS
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | RANK_NUMBERS |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |            1 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |            2 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |            1 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |            1 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |            3 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |            4 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |            1 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |            2 |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+
8 rows in set (0.00 sec)

##--BUT WE NEED THE TOP 3 HIGHEST PAID SALARY RANK IN EACH DEPARTMENT

mysql> SELECT *
    -> FROM (SELECT E.*,
    -> RANK() OVER(PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS RANK_NUMBERS
    -> FROM EMPLOYEE AS E) AS X
    -> WHERE X.RANK_NUMBERS <= 3;
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | RANK_NUMBERS |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |            1 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |            2 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |            1 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |            1 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |            3 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |            1 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |            2 |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+
7 rows in set (0.00 sec)

#DENSE WILL HELP THE FIND THE WITHOUT SKIPPING THE VALUE 

mysql> SELECT E.*,
    -> RANK() OVER(PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS RANK_NUMBERS,
    -> DENSE_RANK() OVER(PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS DENSE_NUMBERS
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+---------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | RANK_NUMBERS | DENSE_NUMBERS |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+---------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |            1 |             1 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |            2 |             2 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |
      1 |             1 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |            1 |             1 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |            3 |             2 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |            4 |             3 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |            1 |             1 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |            2 |             2 |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------+---------------+
8 rows in set (0.00 sec)

#COMAPARITON BETWEEN THE ROW_NUMBER() AND RANK() AND DENSE_RANK()

mysql> SELECT E.*,
    -> ROW_NUMBER() OVER(PARTITION BY DEPARTMENT ORDER BY SALARY DESC ) AS ROW_NUMBERS,
    -> RANK() OVER(PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS RANK_NUMBERS,
    -> DENSE_RANK() OVER(PARTITION BY DEPARTMENT ORDER BY SALARY DESC) AS DENSE_NUMBERS
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+--------------+---------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | ROW_NUMBERS | RANK_NUMBERS | DENSE_NUMBERS |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+--------------+---------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |           1 |            1 |             1 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |           2 |            2 |             2 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |           1 |            1 |             1 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |           2 |            1 |             1 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |           3 |            3 |             2 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |           4 |            4 |             3 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |           1 |            1 |             1 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |           2 |            2 |             2 |
+-------------+------------+-----------+--------+---------------------+------------+------------+-------------+--------------+---------------+
8 rows in set (0.00 sec)

#####  LAG AND LEAD FUNCTION  IN WINDOW 
LAG WILL FIND TO HELP PREVIOUS DETAILS 

mysql> SELECT E.*,
    -> LAG(SALARY) OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) AS PREVIOUS_EMPLOYEE_SALARY
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | PREVIOUS_EMPLOYEE_SALARY |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |                     NULL |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |                   200000 |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |                     NULL |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |                    80000 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |                   500000 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |                   500000 |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |                     NULL |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |                   100000 |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+
8 rows in set (0.12 sec)


#LEAD WILL HELP THE NEXT EMPLOYEE SALARY 

mysql> SELECT E.*,
    -> LAG(SALARY) OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) AS PREVIOUS_EMPLOYEE_SALARY,
    -> LEAD(SALARY) OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) AS NEXT_EMPLOYEE_SALARY
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+----------------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | PREVIOUS_EMPLOYEE_SALARY | NEXT_EMPLOYEE_SALARY |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+----------------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |                     NULL |                75000 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |                   200000 |                 NULL |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |                     NULL |               500000 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |                    80000 |               500000 |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |                   500000 |                90000 |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |                   500000 |                 NULL |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |                     NULL |               300000 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |                   100000 |                 NULL |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+----------------------+
8 rows in set (0.00 sec)

######--*fetch the salary of the employee is higher or lower or equal to previous employee

mysql> SELECT E.*,
    -> LAG(SALARY) OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) AS PREVIOUS_EMPLOYEE_SALARY,
    -> CASE WHEN E.SALARY >LAG(SALARY) OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) THEN 'HIGHER_THAN_PREVIOUS'
    ->      WHEN E.SALARY <LAG(SALARY) OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) THEN 'LOWER_THAN_PREVIOUS'
    ->      WHEN E.SALARY = LAG(SALARY) OVER(PARTITION BY DEPARTMENT ORDER BY EMPLOYEE_ID ) THEN 'EQUAL_TO_PREVIOUS'
    ->      END SALARY_COMPARISON
    -> FROM EMPLOYEE AS E;
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+----------------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | JOINING_DATE        | DEPARTMENT | MANAGER_ID | PREVIOUS_EMPLOYEE_SALARY | SALARY_COMPARISON    |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+----------------------+
|           6 | Deepak     | Gupta     | 200000 | 2017-06-11 09:00:00 | Account    |         15 |                     NULL | NULL                 |
|           7 | Jennifer   | Paul      |  75000 | 2017-01-20 09:00:00 | Account    |         12 |                   200000 | LOWER_THAN_PREVIOUS  |
|           2 | Jessica    | Kohl      |  80000 | 2017-06-11 09:00:00 | Admin      |          5 |                     NULL | NULL                 |
|           4 | Pratik     | Pandey    | 500000 | 2017-02-20 09:00:00 | Admin      |         20 |                    80000 | HIGHER_THAN_PREVIOUS |
|           5 | Christine  | Robinson  | 500000 | 2017-06-11 09:00:00 | Admin      |          7 |                   500000 | EQUAL_TO_PREVIOUS    |
|           8 | Deepika    | Sharma    |  90000 | 2017-04-11 09:00:00 | Admin      |         17 |                   500000 | LOWER_THAN_PREVIOUS  |
|           1 | James      | Smith     | 100000 | 2017-02-20 09:00:00 | HR         |          2 |                     NULL | NULL                 |
|           3 | Alex       | Garner    | 300000 | 2017-02-20 09:00:00 | HR         |         11 |                   100000 | HIGHER_THAN_PREVIOUS |
+-------------+------------+-----------+--------+---------------------+------------+------------+--------------------------+----------------------+
8 rows in set (0.00 sec)

WORK IN PROGRESSS.............................................
WORK FOR PROGRESS.............................................

PART 2 

-- Script to create the Product table and load data into it.

DROP TABLE product;
CREATE TABLE product
( 
    product_category varchar(255),
    brand varchar(255),
    product_name varchar(255),
    price int
);

INSERT INTO product VALUES
('Phone', 'Apple', 'iPhone 12 Pro Max', 1300),
('Phone', 'Apple', 'iPhone 12 Pro', 1100),
('Phone', 'Apple', 'iPhone 12', 1000),
('Phone', 'Samsung', 'Galaxy Z Fold 3', 1800),
('Phone', 'Samsung', 'Galaxy Z Flip 3', 1000),
('Phone', 'Samsung', 'Galaxy Note 20', 1200),
('Phone', 'Samsung', 'Galaxy S21', 1000),
('Phone', 'OnePlus', 'OnePlus Nord', 300),
('Phone', 'OnePlus', 'OnePlus 9', 800),
('Phone', 'Google', 'Pixel 5', 600),
('Laptop', 'Apple', 'MacBook Pro 13', 2000),
('Laptop', 'Apple', 'MacBook Air', 1200),
('Laptop', 'Microsoft', 'Surface Laptop 4', 2100),
('Laptop', 'Dell', 'XPS 13', 2000),
('Laptop', 'Dell', 'XPS 15', 2300),
('Laptop', 'Dell', 'XPS 17', 2500),
('Earphone', 'Apple', 'AirPods Pro', 280),
('Earphone', 'Samsung', 'Galaxy Buds Pro', 220),
('Earphone', 'Samsung', 'Galaxy Buds Live', 170),
('Earphone', 'Sony', 'WF-1000XM4', 250),
('Headphone', 'Sony', 'WH-1000XM4', 400),
('Headphone', 'Apple', 'AirPods Max', 550),
('Headphone', 'Microsoft', 'Surface Headphones 2', 250),
('Smartwatch', 'Apple', 'Apple Watch Series 6', 1000),
('Smartwatch', 'Apple', 'Apple Watch SE', 400),
('Smartwatch', 'Samsung', 'Galaxy Watch 4', 600),
('Smartwatch', 'OnePlus', 'OnePlus Watch', 220);
COMMIT;




-- All the SQL Queries written during the video

select * from product;


-- FIRST_VALUE 
-- Write query to display the most expensive product under each category (corresponding to each record)
select *,
first_value(product_name) over(partition by product_category order by price desc) as most_exp_product
from product;



-- LAST_VALUE 
-- Write query to display the least expensive product under each category (corresponding to each record)
select *,
first_value(product_name) 
    over(partition by product_category order by price desc) 
    as most_exp_product,
last_value(product_name) 
    over(partition by product_category order by price desc
        range between unbounded preceding and unbounded following) 
    as least_exp_product    
from product
WHERE product_category ='Phone';



-- Alternate way to write SQL query using Window functions
select *,
first_value(product_name) over w as most_exp_product,
last_value(product_name) over w as least_exp_product    
from product
WHERE product_category ='Phone'
window w as (partition by product_category order by price desc
            range between unbounded preceding and unbounded following);
            

            
-- NTH_VALUE 
-- Write query to display the Second most expensive product under each category.
select *,
first_value(product_name) over w as most_exp_product,
last_value(product_name) over w as least_exp_product,
nth_value(product_name, 5) over w as second_most_exp_product
from product
window w as (partition by product_category order by price desc
            range between unbounded preceding and unbounded following);



-- NTILE
-- Write a query to segregate all the expensive phones, mid range phones and the cheaper phones.
select x.product_name, 
case when x.buckets = 1 then 'Expensive Phones'
     when x.buckets = 2 then 'Mid Range Phones'
     when x.buckets = 3 then 'Cheaper Phones' END as Phone_Category
from (
    select *,
    ntile(3) over (order by price desc) as buckets
    from product
    where product_category = 'Phone') x;

mysql> -- FIRST_VALUE
mysql> -- Write query to display the most expensive product under each category (corresponding to each record)
mysql> select *,
    -> first_value(product_name) over(partition by product_category order by price desc) as most_exp_product
    -> from product;
+------------------+-----------+----------------------+-------+----------------------+
| product_category | brand     | product_name         | price | most_exp_product     |
+------------------+-----------+----------------------+-------+----------------------+
| Earphone         | Apple     | AirPods Pro          |   280 | AirPods Pro          |
| Earphone         | Sony      | WF-1000XM4           |   250 | AirPods Pro          |
| Earphone         | Samsung   | Galaxy Buds Pro      |   220 | AirPods Pro          |
| Earphone         | Samsung   | Galaxy Buds Live     |   170 | AirPods Pro          |
| Headphone        | Apple     | AirPods Max          |   550 | AirPods Max          |
| Headphone        | Sony      | WH-1000XM4           |   400 | AirPods Max          |
| Headphone        | Microsoft | Surface Headphones 2 |   250 | AirPods Max          |
| Laptop           | Dell      | XPS 17               |  2500 | XPS 17               |
| Laptop           | Dell      | XPS 15               |  2300 | XPS 17               |
| Laptop           | Microsoft | Surface Laptop 4     |  2100 | XPS 17               |
| Laptop           | Apple     | MacBook Pro 13       |  2000 | XPS 17               |
| Laptop           | Dell      | XPS 13               |  2000 | XPS 17               |
| Laptop           | Apple     | MacBook Air          |  1200 | XPS 17               |
| Phone            | Samsung   | Galaxy Z Fold 3      |  1800 | Galaxy Z Fold 3      |
| Phone            | Apple     | iPhone 12 Pro Max    |  1300 | Galaxy Z Fold 3      |
| Phone            | Samsung   | Galaxy Note 20       |  1200 | Galaxy Z Fold 3      |
| Phone            | Apple     | iPhone 12 Pro        |  1100 | Galaxy Z Fold 3      |
| Phone            | Apple     | iPhone 12            |  1000 | Galaxy Z Fold 3      |
| Phone            | Samsung   | Galaxy Z Flip 3      |  1000 | Galaxy Z Fold 3      |
| Phone            | Samsung   | Galaxy S21           |  1000 | Galaxy Z Fold 3      |
| Phone            | OnePlus   | OnePlus 9            |   800 | Galaxy Z Fold 3      |
| Phone            | Google    | Pixel 5              |   600 | Galaxy Z Fold 3      |
| Phone            | OnePlus   | OnePlus Nord         |   300 | Galaxy Z Fold 3      |
| Smartwatch       | Apple     | Apple Watch Series 6 |  1000 | Apple Watch Series 6 |
| Smartwatch       | Samsung   | Galaxy Watch 4       |   600 | Apple Watch Series 6 |
| Smartwatch       | Apple     | Apple Watch SE       |   400 | Apple Watch Series 6 |
| Smartwatch       | OnePlus   | OnePlus Watch        |   220 | Apple Watch Series 6 |
+------------------+-----------+----------------------+-------+----------------------+
27 rows in set (0.00 sec)

mysql> -- LAST_VALUE
mysql> -- Write query to display the least expensive product under each category (corresponding to each record)
mysql> select *,
    -> first_value(product_name)
    ->     over(partition by product_category order by price desc)
    ->     as most_exp_product,
    -> last_value(product_name)
    ->     over(partition by product_category order by price desc
    ->         range between unbounded preceding and unbounded following)
    ->     as least_exp_product
    -> from product
    -> WHERE product_category ='Phone';
+------------------+---------+-------------------+-------+------------------+-------------------+
| product_category | brand   | product_name      | price | most_exp_product | least_exp_product |
+------------------+---------+-------------------+-------+------------------+-------------------+
| Phone            | Samsung | Galaxy Z Fold 3   |  1800 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Apple   | iPhone 12 Pro Max |  1300 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Samsung | Galaxy Note 20    |  1200 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Apple   | iPhone 12 Pro     |  1100 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Apple   | iPhone 12         |  1000 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Samsung | Galaxy Z Flip 3   |  1000 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Samsung | Galaxy S21        |  1000 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | OnePlus | OnePlus 9         |   800 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Google  | Pixel 5           |   600 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | OnePlus | OnePlus Nord      |   300 | Galaxy Z Fold 3  | OnePlus Nord      |
+------------------+---------+-------------------+-------+------------------+-------------------+
10 rows in set (0.00 sec)

mysql> -- Alternate way to write SQL query using Window functions
mysql> select *,
    -> first_value(product_name) over w as most_exp_product,
    -> last_value(product_name) over w as least_exp_product
    -> from product
    -> WHERE product_category ='Phone'
    -> window w as (partition by product_category order by price desc
    ->             range between unbounded preceding and unbounded following);
+------------------+---------+-------------------+-------+------------------+-------------------+
| product_category | brand   | product_name      | price | most_exp_product | least_exp_product |
+------------------+---------+-------------------+-------+------------------+-------------------+
| Phone            | Samsung | Galaxy Z Fold 3   |  1800 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Apple   | iPhone 12 Pro Max |  1300 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Samsung | Galaxy Note 20    |  1200 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Apple   | iPhone 12 Pro     |  1100 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Apple   | iPhone 12         |  1000 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Samsung | Galaxy Z Flip 3   |  1000 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Samsung | Galaxy S21        |  1000 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | OnePlus | OnePlus 9         |   800 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | Google  | Pixel 5           |   600 | Galaxy Z Fold 3  | OnePlus Nord      |
| Phone            | OnePlus | OnePlus Nord      |   300 | Galaxy Z Fold 3  | OnePlus Nord      |
+------------------+---------+-------------------+-------+------------------+-------------------+
10 rows in set (0.01 sec)

mysql> -- NTH_VALUE
mysql> -- Write query to display the Second most expensive product under each category.
mysql> select *,
    -> first_value(product_name) over w as most_exp_product,
    -> last_value(product_name) over w as least_exp_product,
    -> nth_value(product_name, 5) over w as second_most_exp_product
    -> from product
    -> window w as (partition by product_category order by price desc
    ->             range between unbounded preceding and unbounded following);
+------------------+-----------+----------------------+-------+----------------------+----------------------+-------------------------+
| product_category | brand     | product_name         | price | most_exp_product     | least_exp_product    | second_most_exp_product |
+------------------+-----------+----------------------+-------+----------------------+----------------------+-------------------------+
| Earphone         | Apple     | AirPods Pro          |   280 | AirPods Pro          | Galaxy Buds Live     | NULL                    |
| Earphone         | Sony      | WF-1000XM4           |   250 | AirPods Pro          | Galaxy Buds Live     | NULL                    |
| Earphone         | Samsung   | Galaxy Buds Pro      |   220 | AirPods Pro          | Galaxy Buds Live     | NULL                    |
| Earphone         | Samsung   | Galaxy Buds Live     |   170 | AirPods Pro          | Galaxy Buds Live     | NULL                    |
| Headphone        | Apple     | AirPods Max          |   550 | AirPods Max          | Surface Headphones 2 | NULL                    |
| Headphone        | Sony      | WH-1000XM4           |   400 | AirPods Max          | Surface Headphones 2 | NULL                    |
| Headphone        | Microsoft | Surface Headphones 2 |   250 | AirPods Max          | Surface Headphones 2 | NULL                    |
| Laptop           | Dell      | XPS 17               |  2500 | XPS 17               | MacBook Air          | XPS 13                  |
| Laptop           | Dell      | XPS 15               |  2300 | XPS 17               | MacBook Air          | XPS 13                  |
| Laptop           | Microsoft | Surface Laptop 4     |  2100 | XPS 17               | MacBook Air          | XPS 13                  |
| Laptop           | Apple     | MacBook Pro 13       |  2000 | XPS 17               | MacBook Air          | XPS 13                  |
| Laptop           | Dell      | XPS 13               |  2000 | XPS 17               | MacBook Air          | XPS 13                  |
| Laptop           | Apple     | MacBook Air          |  1200 | XPS 17               | MacBook Air          | XPS 13                  |
| Phone            | Samsung   | Galaxy Z Fold 3      |  1800 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | Apple     | iPhone 12 Pro Max    |  1300 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | Samsung   | Galaxy Note 20       |  1200 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | Apple     | iPhone 12 Pro        |  1100 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | Apple     | iPhone 12            |  1000 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | Samsung   | Galaxy Z Flip 3      |  1000 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | Samsung   | Galaxy S21           |  1000 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | OnePlus   | OnePlus 9            |   800 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | Google    | Pixel 5              |   600 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Phone            | OnePlus   | OnePlus Nord         |   300 | Galaxy Z Fold 3      | OnePlus Nord         | iPhone 12               |
| Smartwatch       | Apple     | Apple Watch Series 6 |  1000 | Apple Watch Series 6 | OnePlus Watch        | NULL                    |
| Smartwatch       | Samsung   | Galaxy Watch 4       |   600 | Apple Watch Series 6 | OnePlus Watch        | NULL                    |
| Smartwatch       | Apple     | Apple Watch SE       |   400 | Apple Watch Series 6 | OnePlus Watch        | NULL                    |
| Smartwatch       | OnePlus   | OnePlus Watch        |   220 | Apple Watch Series 6 | OnePlus Watch        | NULL                    |
+------------------+-----------+----------------------+-------+----------------------+----------------------+-------------------------+
27 rows in set (0.00 sec)

mysql> ^C
mysql> -- NTILE
mysql> -- Write a query to segregate all the expensive phones, mid range phones and the cheaper phones.
mysql> select x.product_name,
    -> case when x.buckets = 1 then 'Expensive Phones'
    ->      when x.buckets = 2 then 'Mid Range Phones'
    ->      when x.buckets = 3 then 'Cheaper Phones' END as Phone_Category
    -> from (
    ->     select *,
    ->     ntile(3) over (order by price desc) as buckets
    ->     from product
    ->     where product_category = 'Phone') x;
+-------------------+------------------+
| product_name      | Phone_Category   |
+-------------------+------------------+
| Galaxy Z Fold 3   | Expensive Phones |
| iPhone 12 Pro Max | Expensive Phones |
| Galaxy Note 20    | Expensive Phones |
| iPhone 12 Pro     | Expensive Phones |
| iPhone 12         | Mid Range Phones |
| Galaxy Z Flip 3   | Mid Range Phones |
| Galaxy S21        | Mid Range Phones |
| OnePlus 9         | Cheaper Phones   |
| Pixel 5           | Cheaper Phones   |
| OnePlus Nord      | Cheaper Phones   |
+-------------------+------------------+
10 rows in set (0.00 sec)


-- CUME_DIST (cumulative distribution) ; 
/*  Formula = Current Row no (or Row No with value same as current row) / Total no of rows */

-- Query to fetch all products which are constituting the first 30% 
-- of the data in products table based on price.
select product_name, cume_dist_percetage
from (
    select *,
    cume_dist() over (order by price desc) as cume_distribution,
    round(cume_dist() over (order by price desc)::numeric * 100,2)||'%' as cume_dist_percetage
    from product) x
where x.cume_distribution <= 0.3;




-- PERCENT_RANK (relative rank of the current row / Percentage Ranking)
/* Formula = Current Row No - 1 / Total no of rows - 1 */

-- Query to identify how much percentage more expensive is "Galaxy Z Fold 3" when compared to all products.
select product_name, per
from (
    select *,
    percent_rank() over(order by price) ,
    round(percent_rank() over(order by price)::numeric * 100, 2) as per
    from product) x
where x.product_name='Galaxy Z Fold 3';

